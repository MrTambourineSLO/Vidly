/*	===		BUILDING RESTful SERVICES W/ WebAPI	===	*/
			/*	===		WHAT IS A Web API	===	*/

- > So ASP.NET MVC architecture is like this:
CLIENT --request--> SERVER
	>> When request arrives at our app MVC FW hands off that req to
	an ACTION on a CONTROLLER
		>>> ACTION -most of the time- returns a VIEW
			>>>> VIEW is parsed by RAZOR engine then
			HTML markup is returned to the client
	>> In above approach HTML is generated by the SERVER
- > ALTERNATIVE to generate HTML
	>> ON CLIENT -> insted of ACTIONS returning MARKUP they can return
	RAW DATA
	>> BENEFITS:
		>>>	Less server resources (improve scalability) - each client is 
		responsible for generating their own views
		>>>	Raw data requires LESS BANDWIDTH than HTML markup
		>>> Support for broad range of CLIENTS (mobile apps which
		call endpoints)
		>>> We call those ENDPOINTS:
			>>>> DATA SERVICES or
			>>>> APIs
		>>> Other websites can also consume our API and build new 
		functionality
	>> Those APIs aren't necessarily just for ADDING data, we can also
	add ones to MODIFY the data.
- > The framework we use to build those DATA SERVICES is 
	ASP.NET Web API
	>> It follows same architectural principles as MVC:
		>>>	It has routing, controller, action, action result..
- > Essentially Web API is HTTP service
			
			/*	===		RESTful CONVENTION	===	*/

- > Our API endpoint for CRUD operations on customers will be at /api/customers
- > We're going to support few different types of requests:
	>> GET request on endpoint will return a list of customers
	>> GET -||- w/id ie /api/customers/id will return a single customer
	>> POST creates a resource
	>> PUT to create a customer
	>> DELETE
		>>> Above in terms of request types & endpoints is standard convention
		named RESTful CONVENTION
		=REpresentational State Transfer

			/*	===		BUILDING an API	===	*/

- > Controllers -> New Folder [Api] -> Add -> Controller - > WebApi2 Controller ->
CustomersController(note the plural)
- > Follow the readme.txt's 3rd instruction
- > Our API C. derives from ApiCOntroller
	

	private ApplicationDbContext _context;
	ctor CustomerController(){
		_context = new ApplicationDbContext();
	}
	//Remember IEnumerable is most generic & allows foreach
	Add action: pulbic IEnumerable<Customer> GetCustomers(){
		//Because we're returning list of objects
		//by convention this action will respond to
		// GET /api/customers
		return _context.Customers.ToList();

	}
	//GET api/cutomers/{id}
	public Customer GetCustomer(int id){
		var customer = _contex.Customers.SingleOrDefault(i => i.Id == id);
		if(customer == null){
			//below exception is part of convention
			throw new HttpResponseException(HttpStatusCode.NotFound);
		}
		return customer;
	}
	// POST /api/customers
	// By convention we return NEWLY CREATED resource to
	// the CLIENT!!!
	// Attribute to respond to post request only
	[HttpPost]
	public Customer CreateCustomer(Customer customer){
		//validate object
		if(!ModelState.IsValid){
			//convention
			throw new HttpResponseException(HttpStatusCode.BadRequest);
		}
		_context.Customers.Add(customer);
		//At this point id will be set by id generator in DB
		_context.SaveChanges();

		return customer;
	}

	//POST /api/customers/1
	//We can EITHER return customer OR void
	[HttpPut]
	public void UpdateCustomer(int id, Customer customer){
		if(!ModelState.IsValid){
			throw new HttpResponseException(HttpStatusCode.BadRequest);
		}
		var customerInDB = _context.customers.SingleOrDefault(c => c.Id == id);
		//Check existance of object (in case of invalid Id)
		if(customerInDB == null){
			throw new HttpResponseException(HttpStatusCode.NotFound);
		}
		//UPDATE CUSTOMER:
		customerInDB.Name = customer.Name;
		Birthdate,IsSubscribed, MembershipId;

		_context.SaveChanges();
	}

	// DELETE /api/customers/{id}
	[HttpDelete]
	public void DeleteCustomer(int id){
		var customerInDB = _context.customers.SingleOrDefault(c => c.Id == id);
		//Check existance of object (in case of invalid Id)
		if(customerInDB == null){
			throw new HttpResponseException(HttpStatusCode.NotFound);
		}
		_context.customers.Remove(customerInDb);
		_context.SaveChanges();
	}
			/*	===		TESTING an API	===	*/

- > Can check in browser eg /api/customers
	>> It returns an XML
- > Better way to test is to install Postman rest client shortcut plugin
(or an app Postman)
	>> In postman we first send a get req on /api/customers,
	set output to JSON & then copy one 
	of the customers.
	>> We change req to Post and in Body check raw data, copy/paste customer
	delete id (it's auto-generated) 
	>> In headers we apply key/value type Content-type application/json
	and click send
	>> As per API customer is then returned and we can see his newly
	appointed ID!!!
	>> Good app for checking ENDPOINTS - GOOD PRACTICE before writing any
	javascript