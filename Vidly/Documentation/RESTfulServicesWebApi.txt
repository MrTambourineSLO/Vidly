/*	===		BUILDING RESTful SERVICES W/ WebAPI	===	*/
			/*	===		WHAT IS A Web API	===	*/

- > So ASP.NET MVC architecture is like this:
CLIENT --request--> SERVER
	>> When request arrives at our app MVC FW hands off that req to
	an ACTION on a CONTROLLER
		>>> ACTION -most of the time- returns a VIEW
			>>>> VIEW is parsed by RAZOR engine then
			HTML markup is returned to the client
	>> In above approach HTML is generated by the SERVER
- > ALTERNATIVE to generate HTML
	>> ON CLIENT -> insted of ACTIONS returning MARKUP they can return
	RAW DATA
	>> BENEFITS:
		>>>	Less server resources (improve scalability) - each client is 
		responsible for generating their own views
		>>>	Raw data requires LESS BANDWIDTH than HTML markup
		>>> Support for broad range of CLIENTS (mobile apps which
		call endpoints)
		>>> We call those ENDPOINTS:
			>>>> DATA SERVICES or
			>>>> APIs
		>>> Other websites can also consume our API and build new 
		functionality
	>> Those APIs aren't necessarily just for ADDING data, we can also
	add ones to MODIFY the data.
- > The framework we use to build those DATA SERVICES is 
	ASP.NET Web API
	>> It follows same architectural principles as MVC:
		>>>	It has routing, controller, action, action result..
- > Essentially Web API is HTTP service
			
			/*	===		RESTful CONVENTION	===	*/

- > Our API endpoint for CRUD operations on customers will be at /api/customers
- > We're going to support few different types of requests:
	>> GET request on endpoint will return a list of customers
	>> GET -||- w/id ie /api/customers/id will return a single customer
	>> POST creates a resource
	>> PUT to create a customer
	>> DELETE
		>>> Above in terms of request types & endpoints is standard convention
		named RESTful CONVENTION
		=REpresentational State Transfer

			/*	===		BUILDING an API	===	*/

- > Controllers -> New Folder [Api] -> Add -> Controller - > WebApi2 Controller ->
CustomersController(note the plural)
- > Follow the readme.txt's 3rd instruction
- > Our API C. derives from ApiCOntroller
	

	private ApplicationDbContext _context;
	ctor CustomerController(){
		_context = new ApplicationDbContext();
	}
	//Remember IEnumerable is most generic & allows foreach
	Add action: pulbic IEnumerable<Customer> GetCustomers(){
		//Because we're returning list of objects
		//by convention this action will respond to
		// GET /api/customers
		return _context.Customers.ToList();

	}
	//GET api/cutomers/{id}
	public Customer GetCustomer(int id){
		var customer = _contex.Customers.SingleOrDefault(i => i.Id == id);
		if(customer == null){
			//below exception is part of convention
			throw new HttpResponseException(HttpStatusCode.NotFound);
		}
		return customer;
	}
	// POST /api/customers
	// By convention we return NEWLY CREATED resource to
	// the CLIENT!!!
	// Attribute to respond to post request only
	[HttpPost]
	public Customer CreateCustomer(Customer customer){
		//validate object
		if(!ModelState.IsValid){
			//convention
			throw new HttpResponseException(HttpStatusCode.BadRequest);
		}
		_context.Customers.Add(customer);
		//At this point id will be set by id generator in DB
		_context.SaveChanges();

		return customer;
	}

	//POST /api/customers/1
	//We can EITHER return customer OR void
	[HttpPut]
	public void UpdateCustomer(int id, Customer customer){
		if(!ModelState.IsValid){
			throw new HttpResponseException(HttpStatusCode.BadRequest);
		}
		var customerInDB = _context.customers.SingleOrDefault(c => c.Id == id);
		//Check existance of object (in case of invalid Id)
		if(customerInDB == null){
			throw new HttpResponseException(HttpStatusCode.NotFound);
		}
		//UPDATE CUSTOMER:
		customerInDB.Name = customer.Name;
		Birthdate,IsSubscribed, MembershipId;

		_context.SaveChanges();
	}

	// DELETE /api/customers/{id}
	[HttpDelete]
	public void DeleteCustomer(int id){
		var customerInDB = _context.customers.SingleOrDefault(c => c.Id == id);
		//Check existance of object (in case of invalid Id)
		if(customerInDB == null){
			throw new HttpResponseException(HttpStatusCode.NotFound);
		}
		_context.customers.Remove(customerInDb);
		_context.SaveChanges();
	}
			/*	===		TESTING an API	===	*/

- > Can check in browser eg /api/customers
	>> It returns an XML
- > Better way to test is to install Postman rest client shortcut plugin
(or an app Postman)
	>> In postman we first send a get req on /api/customers,
	set output to JSON & then copy one 
	of the customers.
	>> We change req to Post and in Body check raw data, copy/paste customer
	delete id (it's auto-generated) 
	>> In headers we apply key/value type Content-type application/json
	and click send
	>> As per API customer is then returned and we can see his newly
	appointed ID!!!
	>> Good app for checking ENDPOINTS - GOOD PRACTICE before writing any
	javascript

			/*	===		DATA TRANSFER OBJECTS	===	*/

- > Problem: Our API recieves/returns customer objects.
	>> What's the problem here?
	>> Customer is part of domain model of our application, which is considered
	IMPLEMENTATION DETAIL - which can change frequently - and break clients
	dependent on API
- > We need to make contract of our API more stable:
- > To change this we need a different model which we call DTO
(DATA TRANSFER OBJECT)
	>> This is plain data structure used to transfer data from the client
	to the server or vice versa. We have to be careful changing API -
	ie a topic of API verisoning
- > In short: 
	>> We should never return DOMAIN OBJECTS
	>> With above it also exposes our data to security risks
	W/ DTO we can exclude eg properties that should not be updated.
- > New folder DTOs -> class CustomerDTO
	>> Copy properties from customer class
		>>> We exclude MembershipType, if we wanted to return MembershipType
		we'd have to implement new MembershipTypeDTO type
		>>> In short we only return primitive type or custom details
		>>> For returning hierarhical data structures we create DTOs so we
		completely decouple them from domain objects.
	>> We don't need display attributes which are for forms only
	>> Back in controller, wherever we return Domain Object we need to 
	map them to DTO first, also in methods where we modify customer 
	we need to map this customer DTO properties back to our customer 
	object.
- > To avoid tediousness we'll use:

			/*	===		AUTO MAPPER	===	*/

PM> install-package automapper -version:4.1
- > Now we need to create mapping profile which defines how 
	objects of different types can be mapped to each other.
- > App_start -> new class -> "MappingProfile"
	>> We derive from Profile in Automapper namespace
	>> ctor
		//CreateMapper takes two objects we intend to map to each other
		>>> Mapper.CreateMap<Customer, CustomerDto>();
		>>> Mapper.CreateMap<CustomerDto,Customer >();
		//AM uses reflection to scan types find properties and map 
		them based on their name - ie CONVENTION BASED MAPPING TOOL
		(because it uses property names as convention to map objects)
- > Now we need to load this profile when the app starts:
	>> Global.asax.cs - at top:
		Mapper.Initialize(takes lambda, ie action)
		Mapper.Initialize(c => c.AddProfile<MappingProfile>)
- > In controller we change all customer instances to CustomerDto
- > in return for IEnumerable<CustomerDto> ReturnCustomers(){
	return _context.Customers.ToList().Select(Mapper.Map<Customer,CustomerDto>);
}
	>> We need to map return object to CustomerDto
	>> We do that by calling Linq extension method Select()
	>> In it we need to pass a DELEGATE that does the mapping
	>> Mapper.Map<source,target> - without parentheses, because we're
	not calling method but we need a delegeate, ie reference to this method
- > In GetCustomer we're returning only one object so we cannot use Select
from Linq, insted we return Mapper.Map<Customer,CustomerDto>(customer);
- > In methods where we POST we need to make a new 
customer object and Mapper.Map customerdto to customer
After we save changes we need to add Id to Dto object
- > PUT:
	>> After checking if object is foung we map customerdto to customer like this:
	Mapper.Map<CustomerDto, Customer>(customerDto, customerInDb)
		>>> We do this because we have an EXISTING object to modify and
		we're not assigning it o a new (var) object as before
		+ We no longer need those assignments below

			/*	===		CAMEL NOTATION	===	*/

- > Minor problem is endpoint returns properties in PASCAL notation, bu JS
uses camelNotation
- > Let's configure api to return JSON obj w/ CN
	We open WebApiConfig
		>> At top of Register method:
		var setting = config.Formatters.JsonFormatter.SerializerSettings;
		settings.ContractResolver = new CamelCasePropertyNamesContractResolver();
		setting.Formatting = Formatting.Indented;


			/*	===		IHttpActionResult	===	*/
				(ie ActionResult in WebApis)

- > Right now when we return DTO status code is 200 OK, but in
RESTFul convention status code should be 201 CREATED
- > Instead of returning DTO we must return IHttpActionResult
	>> It's similar to ActionResult
	>> It has many helper mehods, we can simply return BadRequest()
	insted of throwing new exception
	>> Insted of returning customer DTO we 
	return Created() method
		>>> Insted of DTO we return URI
		[UNIFIED RESOURCE INDENTIFIER]
		so we return 
		new Uri((uri of our current request +"/"+ id of our object),
				DTO); -ergo api/customers/4
		>>> Uri of current request is Request.RequestUri
		>>> We also temporarily comment our our custom attributes
		in CustomerDTO because we're casting our ObjectInstance on Customer and 
		not a DTO.
- > When we return a single instance of IHAR we return Ok(with previous parameters)


			/*	===		EXERCISE	===	*/

API for CRUD operations around MOVIES.
-> Endpoint:
	GetAll(),Get(id),Add,Update,Delete
				
