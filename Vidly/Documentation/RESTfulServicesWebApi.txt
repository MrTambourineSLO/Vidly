/*	===		BUILDING RESTful SERVICES W/ WebAPI	===	*/
			/*	===		WHAT IS A Web API	===	*/

- > So ASP.NET MVC architecture is like this:
CLIENT --request--> SERVER
	>> When request arrives at our app MVC FW hands off that req to
	an ACTION on a CONTROLLER
		>>> ACTION -most of the time- returns a VIEW
			>>>> VIEW is parsed by RAZOR engine then
			HTML markup is returned to the client
	>> In above approach HTML is generated by the SERVER
- > ALTERNATIVE to generate HTML
	>> ON CLIENT -> insted of ACTIONS returning MARKUP they can return
	RAW DATA
	>> BENEFITS:
		>>>	Less server resources (improve scalability) - each client is 
		responsible for generating their own views
		>>>	Raw data requires LESS BANDWIDTH than HTML markup
		>>> Support for broad range of CLIENTS (mobile apps which
		call endpoints)
		>>> We call those ENDPOINTS:
			>>>> DATA SERVICES or
			>>>> APIs
		>>> Other websites can also consume our API and build new 
		functionality
	>> Those APIs aren't necessarily just for ADDING data, we can also
	add ones to MODIFY the data.
- > The framework we use to build those DATA SERVICES is 
	ASP.NET Web API
	>> It follows same architectural principles as MVC:
		>>>	It has routing, controller, action, action result..
- > Essentially Web API is HTTP service
			
			/*	===		RESTful CONVENTION	===	*/

- > Our API endpoint for CRUD operations on customers will be at /api/customers
- > We're going to support few different types of requests:
	>> GET request on endpoint will return a list of customers
	>> GET -||- w/id ie /api/customers/id will return a single customer
	>> POST creates a resource
	>> PUT to create a customer
	>> DELETE
		>>> Above in terms of request types & endpoints is standard convention
		named RESTful CONVENTION
		=REpresentational State Transfer

			/*	===		BUILDING an API	===	*/

- > Controllers -> New Folder [Api] -> Add -> Controller - > WebApi2 Controller ->
CustomersController(note the plural)
- > Follow the readme.txt's 3rd instruction
- > Our API C. derives from ApiCOntroller
	

	private ApplicationDbContext _context;
	ctor CustomerController(){
		_context = new ApplicationDbContext();
	}
	//Remember IEnumerable is most generic & allows foreach
	Add action: pulbic IEnumerable<Customer> GetCustomers(){
		//Because we're returning list of objects
		//by convention this action will respond to
		// GET /api/customers
		return _context.Customers.ToList();

	}
	//GET api/cutomers/{id}
	public Customer GetCustomer(int id){
		var customer = _contex.Customers.SingleOrDefault(i => i.Id == id);
		if(customer == null){
			//below exception is part of convention
			throw new HttpResponseException(HttpStatusCode.NotFound);
		}
		return customer;
	}
	// POST /api/customers
	// By convention we return NEWLY CREATED resource to
	// the CLIENT!!!
	// Attribute to respond to post request only
	[HttpPost]
	public Customer CreateCustomer(Customer customer){
		//validate object
		if(!ModelState.IsValid){
			//convention
			throw new HttpResponseException(HttpStatusCode.BadRequest);
		}
		_context.Customers.Add(customer);
		//At this point id will be set by id generator in DB
		_context.SaveChanges();

		return customer;
	}

	//POST /api/customers/1
	//We can EITHER return customer OR void
	[HttpPut]
	public void UpdateCustomer(int id, Customer customer){
		if(!ModelState.IsValid){
			throw new HttpResponseException(HttpStatusCode.BadRequest);
		}
		var customerInDB = _context.customers.SingleOrDefault(c => c.Id == id);
		//Check existance of object (in case of invalid Id)
		if(customerInDB == null){
			throw new HttpResponseException(HttpStatusCode.NotFound);
		}
		//UPDATE CUSTOMER:
		customerInDB.Name = customer.Name;
		Birthdate,IsSubscribed, MembershipId;

		_context.SaveChanges();
	}

	// DELETE /api/customers/{id}
	[HttpDelete]
	public void DeleteCustomer(int id){
		var customerInDB = _context.customers.SingleOrDefault(c => c.Id == id);
		//Check existance of object (in case of invalid Id)
		if(customerInDB == null){
			throw new HttpResponseException(HttpStatusCode.NotFound);
		}
		_context.customers.Remove(customerInDb);
		_context.SaveChanges();
	}
			/*	===		TESTING an API	===	*/

- > Can check in browser eg /api/customers
	>> It returns an XML
- > Better way to test is to install Postman rest client shortcut plugin
(or an app Postman)
	>> In postman we first send a get req on /api/customers,
	set output to JSON & then copy one 
	of the customers.
	>> We change req to Post and in Body check raw data, copy/paste customer
	delete id (it's auto-generated) 
	>> In headers we apply key/value type Content-type application/json
	and click send
	>> As per API customer is then returned and we can see his newly
	appointed ID!!!
	>> Good app for checking ENDPOINTS - GOOD PRACTICE before writing any
	javascript

			/*	===		DATA TRANSFER OBJECTS	===	*/

- > Problem: Our API recieves/returns customer objects.
	>> What's the problem here?
	>> Customer is part of domain model of our application, which is considered
	IMPLEMENTATION DETAIL - which can change frequently - and break clients
	dependent on API
- > We need to make contract of our API more stable:
- > To change this we need a different model which we call DTO
(DATA TRANSFER OBJECT)
	>> This is plain data structure used to transfer data from the client
	to the server or vice versa. We have to be careful changing API -
	ie a topic of API verisoning
- > In short: 
	>> We should never return DOMAIN OBJECTS
	>> With above it also exposes our data to security risks
	W/ DTO we can exclude eg properties that should not be updated.
- > New folder DTOs -> class CustomerDTO
	>> Copy properties from customer class
		>>> We exclude MembershipType, if we wanted to return MembershipType
		we'd have to implement new MembershipTypeDTO type
		>>> In short we only return primitive type or custom details
		>>> For returning hierarhical data structures we create DTOs so we
		completely decouple them from domain objects.
	>> We don't need display attributes which are for forms only
	>> Back in controller, wherever we return Domain Object we need to 
	map them to DTO first, also in methods where we modify customer 
	we need to map this customer DTO properties back to our customer 
	object.
- > To avoid tediousness we'll use:

			/*	===		AUTO MAPPER	===	*/