			/*	===		OVERVIEW	===	*/


- > Premature optimization is root of all evils (-:
- > Don't sacrifice maintenablility of code for performance optimization
- > Optimize ONLY when you need to.
- > most web apps follow THREE-TIER ARCHITECTURE:
							(tier is where the code runs)
	>> DATA (Db & Queries)
	>> Aplication (|| midle tier (IIS))
	>> CLIENT (frontend - Browser)

	>> Most bottlenecks appear in DATA TIER (gain is usually in seconds)
	Higher we go, less observable the gain.
	(ie it doesn't really matter if we improve loading time by 20ms)

			/*	===		DATA TIER	===	*/

- > Problems are either in SCHEMA or QUERIES
	>> SCHEMA:
		>>> Make sure every table has PK
		>>> Relationships
		>>> Use Indexers on tables that you use for
		filtering records in your queries

		* W/ CodeFirst our migrations automatically add PK & Indexers
		* It's also a bad idea to have E-A-V(Entities -Attributes - Values)
		architecture for DB, while it's very maintenable it has severe problems:
			>> Can't use ORM 
			>> Queries are extremely long
			>> Performance problems (30 seconds query)

	>> QUERIES:
		>>> In our app so far all queries were generated by EF
		>>> It's good though to keep an eye on what kind of queries
		EF is running on DB
		- Sometimes we'll want to write a stored procedure and run an
		optimized query of our own.
		>>> In SQL SERVER we have feature "Execution Plan" which shows
		how Server executes our queries
		>>> If after all queries are still slow we could then write 
		so called "Read" DB (CQRS) - essentially if we read data more
		than modify it we can create DB more optimized for reading data
		Essentially we PRE-JOIN tables - since joining impacts performance
		 >>>> Then we have to MAINTAIN 2 DBs in SYNC
		>>> Use CACHING: we run slow query and then store it in memory
			>>>> Subsequent requests will be server from cache.

				/*	===		GLIMPSE	===	*/

Diagnostic tool:
- > PM> install-package glimpse.mvc5
		>install-package glimpse.ef6
- > Now we run our app and navigate to localhost:44300/glimpse.axd
- > Turn Glimpse on
- > Sets cookie on our machine and is passed back & forth w/ each request
	>> On server G has module taht intercepts every REQ
- > Now we navigate to list of customers
	>> On bottom of screen we get a bar:
	3 tabs:
	HTTP/HOST/AJAX
	>> If we click on big G at bottom right we get even more diagnostics
		>>> Click AJAX
			>>> Now we can go to SQL and see all info including what queries were
				executed - in our case it was a SINGLE QUERY
	>> Video explains how bad is a practice of doing VIRTUAL PROPS ON MODELS
	(that's what even MS videos tend to teach) [eg public virtual MembershipType MembershipType{get;set;}]
		>>>	W/ above we get LAZY LOADING (3 sql queries for list of customers)
		, we were doing EAGER LOADING (1 request for list of customers)
		(eg Include method is part of EAGER LOADING)
		(EL =  Loading bunch of objects together in a sense:
		SELECT *
		FROM...
		INNER JOIN...
		INNER JOIN...)
		>>>	In LAZY LOADING it's more like:(
		SLECT *
		FROM...

		SLECT *
		FROM...

		SLECT *
		FROM...
		)
		Ergo: Objects are loaded only if our code touches 1 or more of
		navigation properties of an object
		>> In reality we MUST KNOW AOT what data we're going to return
		to client
		W/ LL we have multiple back trips to DB and significant impact on
		speed
		>> In LL for example when EF sees customer.MembershipType it will open
		new connection make new query for membership type, close connection and
		repeat this for each customer in the list
			>>> Thus if we have N customers in the list we'll have 1 query to 
			get the list of customers and N queries to get Membership type for
			each customer
		This is called /* N+1 ISSUE */ - CONSEQUENCE OF LAZY LOADING
		ALLWAYS AVOID LAZY LOADING
		
		(Doing stored procedures is part of EF tutorial on UDEMY)
				
				/*	===		APPLICATION TIER	===	*/

				/*	===		OUTPUT CACHING	===	*/

- > If schema and queries are in good form we trasition to APPLICATION TIER
- > Most gainful here is Output Caching
- > If we give @DateTime.Now.ToString() in our Index page 
	Let's say that we see in diagnostics that this is a heavy query with 
	big impact on application
	>> If data behind this does NOT change this OFTEN we can cache output
	>> 1st time someone visits the page we'll query the DB and then render
	HTML and save both to CACHE
	Next time EF will use CACHE to render the page
- > In HomeController decorate Index AR w/ [OutputCache(Duration = *in seconds*] - this is ActionFilter
- > We can CACHE data on server or client - If view is specific to given user 
we cache it on client... [OutputCache(Duration = 50, Location = OutputCacheLocation.Server)]
	>> Another property in OutputCache is **VaryByParam = "value"**
		>>> If this action takes 1 || > parameters and output changes on value of
		these parameters we can CACHE each output separately
		If we gave it a value eg "genre" we'll have a different variant of this
		page in CACHE for every GENRE
		If we have many params we can use "*" which means: for every combination of
		this parameter
- > AGAIN: ALWAYS DO OPTIMIZATION @ THE END, DON'T ASSUME PROBLEMS BEFOREHAND
- > We can also disable caching on a particular action:
	[OutputCache(Duration = 0, VaryByParam ="*", NoStore = true)] // Disable caching


				/*	===		DATA CACHING	===	*/

- > In Index AR (customerscontroller) imagine we want to cache list of genres
//If memory cache of genres is null
if(MemoryCache.Default["Genres"] == null){
	//We get it from DB
	MemoryCache.Default["Genres"] = _context.Genres.TolIst();
}
	//Otherwise we get genres from cache (it returns an object
	//so we need to cast  it to IEnumberabe of Genres)
	var genres = MemoryCache.Default["Genres"] as IEnumerable<Genre>;
	//Again it's prudent to avoid "magic strings" it's better to use some
	//constant strings for that
- > AGAIN: ALWAYS DO OPTIMIZATION @ THE END, DON'T ASSUME PROBLEMS BEFOREHAND
	(W/ caching we can increase memory consumption of an app if not done correctly +
	there is layer of complexities, especially in EF if we're referencing some data
	that's not CACHED)
- > Only use for ACTIONS that are DISPLAYING NOT MODIFYING DATA.

					/*	===		ASYNC	===	*/

- > Async...Await WON'T necessarily IMPROVE PERFORMANCE:
HOW IT WORKS:
*When we recieve a REQUEST runtime allocates a THREAD to handle that request.
 - When it comes to I/O BOUND operations like ACCESSING A DB or FILE
	or NETWORK BOUND operations like ACCESSING REMOTE SERVICE
	there's ALLWAYS a delay
	-Eg: Thread HAS TO WAIT until DB *executes query* and *returns* a result.
 -We have a limited amount of MEMORY and THREADS available on server
 if we have many CONCURRENT USERS we may RUN OUT of threads because those threads
 may be waiting for IO BOUND || NETWORK BOUND operations to complete.
	>> Here we either need better hardware or use ASYNC...AWAIT
	>> SO: If we use ASYNC thread will be released to handle another request
	but it WILL NOT improve PERFORMANCE because it has TO AWAIT response from
	DB - BUT IT WILL be able to serve MORE CONCURRENT users:
	ERGO: Better SCALABILITY (if we're not using only a single instance of SQL server)
	 not PERFORMANCE
			>> Even that's not always true: if we're using SINGLE INSTANCE of
			SQL server that's gonna be our BOTTLENECK
			>> It's a different story if we use SQL cluster or NoSQL (Mongo,Raven)
			which are designed for scalability or Azure.

				/*	===		RELEASE BUILDS	===	*/

Application Tier:
besides
*Output Caching &
*Data Caching
another simple optimization is
*Release Builds
- > In VS we have a dropdown w/ a default Debug selected which adds additional
assemblies and data. It's slightly faster w/ RELESE BUILD

				
				/*	===		DISABLING SESSION	===	*/

- > Should be avoided at all costs.
- > SESSION: piece of memory in the web server allocated to each USER
	>> Here we story temporary data during the user session
	>> Kills scalability - more users = more memory used
	>> To make apps scalable we should make them STATELESS which means
	request comes - get's processed and we're done - we DON'T maintain STATE
	WE DON'T use SESSION
- > How to disable:
	>> Solution Explorer:Web.Config - System.Web add 
	<sessionState mode ="Off"> (value is case sensitive so Off should be capitalized)
	at the top
- > TL;DR - 4 Application Tier Optimizations:
	*Output Caching
	*Data Caching
	*Release Builds
	*Disabling Session
	//Last two are SAFE w/o performance profiling


				/*	===		CLIENT TIER	===	*/

Based on 2 simple priciples:
*Client - Server are located at different locations
=> We should therfore reduce the NR. OF REQUESTS and also
SIZE OF THE RESPONSE
	- > We can apply this priciple in 
	DTO (When building APIs we should build are DTOs Lightweight)
	JS (BUNDLING)-ALSO: Scripts should be put at the END OF BODY
	CSS (BUNDLING)-ALSO: Scripts should be put at the END OF BODY
	IMAGE
Enabling Bundling : Web.Config - System.Web <compilation> - 
change debug to false (just to see bundling) -DON'T DO THAT
PERMANENTLY - Since Web.Release.Config will override those
settings at deployment

CHROME P.S.: If network tab shows unreliable data it means 
our browser has some requests cached (release size of bundle
could therefore be larger than in debug mode)
	* In chrome tools - Network -Disable Cache check
				
				
				/*	===		EPILOGUE	===	*/
Premature optimization doensn't mean we should never optimize during
development.
It means we should not spend A LOT OF TIME on it especially if 
it impacts MAINTENABILITY especially in NON CRITICAL parts of app